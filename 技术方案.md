# markview-vue 技术方案

## 一、项目背景

### 1.1 业务场景

我们有两个场景需要渲染 Markdown：

**AI 对话**：AI 返回的内容是 Markdown 格式，包含代码、表格、公式。用户要能快速复制代码，查看公式，体验不能差。

**文档站**：产品文档、API 文档用 Markdown 写的，需要目录导航、代码高亮、暗黑模式。更重要的是，要能在 Markdown 里嵌入自定义组件，比如代码沙箱、可交互的图表。

调研了 Vue 生态的几个库，发现一个核心问题：它们都是基于 marked 或 markdown-it，输出的是 HTML 字符串，没法直接嵌入 Vue 组件。要实现组件嵌入，只能用 `v-html` 渲染后手动操作 DOM 挂载组件，这个方案维护成本太高，而且容易内存泄漏。

我们需要的是编译时就把 Markdown 转成 Vue 组件树，而不是运行时操作 DOM。所以选择了 MDX 这个方案。


### 1.2 为什么自己做

现有的 Vue Markdown 库都是基于 marked 或 markdown-it，它们的架构决定了只能输出 HTML 字符串。这带来一个致命问题：**无法在编译时嵌入 Vue 组件**。

如果用这些库实现组件嵌入，流程是这样的：
1. Markdown → HTML 字符串
2. 用 `v-html` 渲染到 DOM
3. 用 `querySelector` 找到特定节点
4. 手动创建 Vue 实例挂载上去

这个方案有两个大问题：
- 组件生命周期要手动管理，unmount 时容易遗漏导致内存泄漏
- 无法使用 Vue 的响应式系统，父子组件通信很麻烦

我们需要的是 **Markdown → Vue 组件树** 的编译流程，这样组件嵌入是原生支持的，不需要运行时操作 DOM。MDX 就是做这个的。

## 二、技术选型对比

### 2.1 MDX：编译时组件嵌入

MDX 的核心是把 Markdown 编译成 Vue 组件函数，而不是 HTML 字符串。这样就能在 Markdown 里直接写 Vue 组件：

```mdx
# 文档标题

这是普通文本。

<CodeSandbox id="react-demo" />

\`\`\`js
console.log('hello')
\`\`\`
```

编译后生成的是这样的代码：

```js
export default function MDXContent({ components }) {
  return h('div', [
    h('h1', '文档标题'),
    h('p', '这是普通文本。'),
    h(components.CodeSandbox, { id: 'react-demo' }),
    h('pre', [h('code', 'console.log("hello")')])
  ])
}
```

这是标准的 Vue 组件树，不需要运行时操作 DOM。

**组件映射**

MDX 还支持把 HTML 标签映射成自定义组件：

```js
const components = {
  pre: CodeBlock,    // 代码块用 CodeBlock 组件渲染
  table: Table,      // 表格用 Table 组件渲染
  h2: Heading,       // 标题用 Heading 组件渲染
}
```

用户写的是标准 Markdown，但渲染时会用我们的自定义组件。这样就能实现代码复制、表格复制、标题折叠这些功能。

**插件生态**

MDX 兼容 unified 生态的插件：
- `remark-gfm`：表格、任务列表、删除线
- `remark-math` + `rehype-katex`：数学公式
- 其他社区插件可以直接用

## 三、核心架构设计

### 3.1 组件映射机制

MDX 允许将 HTML 标签映射为自定义组件，这是实现高级功能的关键：

```typescript
const mergedComponents = {
  // 代码块：pre 标签 → CodeBlock 组件
  pre: CodeBlock,
  
  // 表格：table 标签 → Table 组件
  table: Table,
  
  // 标题：h1~h6 → Heading 组件
  h1: (props) => h(Heading, { level: 1, ...props }),
  h2: (props) => h(Heading, { level: 2, ...props }),
  
  // 引用块：blockquote → Blockquote 组件
  blockquote: Blockquote,
  
  // 图片：img → MdImage 组件
  img: MdImage,
}
```

这样做的好处：
1. **无侵入**：用户写标准 Markdown，无需关心底层实现
2. **可扩展**：通过 `components` prop 可以覆盖任意标签
3. **类型安全**：组件接收标准 HTML 属性，类型完整

## 四、核心功能实现

### 4.1 代码高亮优化

**问题**：Shiki 默认打包所有语言，体积达 10MB+

**解决方案**：按需加载常用语言

```typescript
// 只打包 15 种常用语言
const BUNDLED_LANGS = [
  'javascript', 'typescript', 'json', 'html', 'css',
  'python', 'bash', 'yaml', 'sql', 'java', 'go',
  'jsx', 'tsx', 'vue', 'scss'
]

// 单例模式，避免重复初始化
let highlighterInstance: HighlighterCore | null = null

export async function getHighlighter() {
  if (highlighterInstance) return highlighterInstance
  
  highlighterInstance = await createHighlighterCore({
    themes: [githubLight],
    langs: BUNDLED_LANGS,
    engine: createOnigurumaEngine(import('shiki/wasm'))
  })
  
  return highlighterInstance
}
```

**效果**：打包体积从 10MB 降至 ~800KB

### 4.2 代码块交互功能

**功能清单**
- ✅ 语言标签显示
- ✅ 一键复制代码
- ✅ 行号显示（可选）
- ✅ 长代码自动折叠

**实现要点**

1. **VNode 解析**：从 MDX 传入的 VNode 中提取代码和语言
```typescript
function extractTextFromVNode(vnode: VNode[]): string {
  // 递归遍历 VNode 树，提取文本内容
  // 处理 string、数组、嵌套组件等情况
}
```

2. **自动折叠**：超过 15 行的代码默认折叠
```typescript
const isCollapsible = computed(() => {
  if (props.collapsible === 'auto') {
    return lineCount.value > props.maxLines // 默认 15 行
  }
  return props.collapsible
})
```

3. **复制功能**：使用 Clipboard API + 降级方案
```typescript
export async function copyToClipboard(text: string): Promise<boolean> {
  if (navigator.clipboard) {
    await navigator.clipboard.writeText(text)
    return true
  }
  
  // 降级：创建临时 textarea
  const textarea = document.createElement('textarea')
  textarea.value = text
  document.body.appendChild(textarea)
  textarea.select()
  const success = document.execCommand('copy')
  document.body.removeChild(textarea)
  return success
}
```

### 4.3 表格增强

**功能**
- ✅ 响应式布局（横向滚动）
- ✅ 表头固定样式
- ✅ 行悬停高亮
- ✅ 一键复制表格内容（TSV 格式）

**复制实现**
```typescript
async function handleCopy() {
  const rows = Array.from(table.querySelectorAll('tr'))
  const text = rows.map(row => {
    const cells = Array.from(row.querySelectorAll('th, td'))
    return cells.map(cell => cell.textContent?.trim() || '').join('\t')
  }).join('\n')
  
  await copyToClipboard(text)
}
```

复制后的内容可直接粘贴到 Excel/Google Sheets。

### 4.4 标题折叠与锚点

**功能**
- ✅ 标题左侧显示折叠按钮（hover 可见）
- ✅ 点击折叠/展开该标题下的所有内容
- ✅ 标题右侧显示锚点图标（hover 可见）
- ✅ 点击锚点复制链接

**实现难点**：如何确定"标题下的内容"

```typescript
function collapseHeadingContent(heading: HTMLElement, level: number, collapsed: boolean) {
  let next = heading.nextElementSibling
  
  while (next) {
    // 遇到同级或更高级标题，停止
    if (next.tagName.match(/^H[1-6]$/)) {
      const nextLevel = parseInt(next.tagName[1])
      if (nextLevel <= level) break
    }
    
    // 切换显示状态
    (next as HTMLElement).style.display = collapsed ? 'none' : ''
    next = next.nextElementSibling
  }
}
```

**状态管理**：使用 `provide/inject` 在组件树中共享折叠状态

```typescript
// 提供折叠状态
export function provideHeadingCollapse() {
  const collapsedIds = ref<Set<string>>(new Set())
  
  provide('headingCollapse', {
    isCollapsed: (id: string) => collapsedIds.value.has(id),
    toggle: (id: string) => {
      if (collapsedIds.value.has(id)) {
        collapsedIds.value.delete(id)
      } else {
        collapsedIds.value.add(id)
      }
    }
  })
}

// 注入折叠状态
const collapseState = inject('headingCollapse')
```

### 4.5 目录（TOC）导航

**功能**
- ✅ 自动提取 H2~H4 标题
- ✅ 滚动时高亮当前位置
- ✅ 点击跳转到对应标题
- ✅ 支持侧边栏/嵌入式两种布局

**实现方案**

1. **提取标题**：渲染完成后从 DOM 中提取
```typescript
function extractToc() {
  const headings = contentRef.value?.querySelectorAll('h1, h2, h3, h4, h5, h6')
  
  headings.forEach(heading => {
    const level = parseInt(heading.tagName[1])
    if (level >= tocMinLevel && level <= tocMaxLevel) {
      tocItems.push({
        level,
        text: heading.textContent?.trim() || '',
        id: heading.id
      })
    }
  })
}
```

2. **滚动高亮**：使用 IntersectionObserver 监听标题可见性
```typescript
const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      activeId.value = entry.target.id
    }
  })
}, {
  rootMargin: '-80px 0px -80% 0px' // 顶部留 80px，底部留 80%
})

// 监听所有标题
tocItems.forEach(item => {
  const el = document.getElementById(item.id)
  if (el) observer.observe(el)
})
```

3. **平滑滚动**：点击 TOC 项时滚动到对应位置
```typescript
function scrollToHeading(id: string) {
  const el = document.getElementById(id)
  if (!el) return
  
  el.scrollIntoView({ behavior: 'smooth', block: 'start' })
}
```

### 4.6 主题系统

**设计原则**：基于 CSS Variables，支持运行时切换

**变量定义**
```scss
:root {
  // 文本颜色
  --md-color-text: #171717;
  --md-color-text-secondary: #525252;
  --md-color-text-tertiary: #a3a3a3;
  
  // 链接
  --md-color-link: #2563eb;
  --md-color-link-hover: #1d4ed8;
  
  // 代码块
  --md-code-header-bg: #f0f0f2;
  --md-code-body-bg: #fafafa;
  --md-code-border: #e5e5e5;
  
  // 表格
  --md-table-border: #e5e5e5;
  --md-table-header-bg: #f9fafb;
  --md-table-hover-bg: #f5f5f5;
}

// 暗色主题
.md-render--dark {
  --md-color-text: #e5e5e5;
  --md-color-text-secondary: #a3a3a3;
  --md-color-text-tertiary: #737373;
  
  --md-color-link: #60a5fa;
  --md-color-link-hover: #93c5fd;
  
  --md-code-header-bg: #1e1e1e;
  --md-code-body-bg: #0d0d0d;
  --md-code-border: #2d2d2d;
  
  --md-table-border: #2d2d2d;
  --md-table-header-bg: #1a1a1a;
  --md-table-hover-bg: #262626;
}
```

**切换方式**
```vue
<MarkdownRender :raw="content" theme="dark" />
```

**自定义主题**
```css
/* 用户可以覆盖任意变量 */
:root {
  --md-color-link: #10b981; /* 绿色链接 */
  --md-code-body-bg: #f8fafc; /* 浅蓝背景 */
}
```

## 五、为什么需要自定义组件

### 5.1 原生 HTML 做不了什么

如果直接用 MDX 输出的原生 HTML，代码块就是一个简单的 `<pre><code>`：

```html
<pre><code class="language-js">console.log('hello')</code></pre>
```

这样的话，复制按钮加不了，语言标签显示不了，折叠功能也没法做。样式定制也很受限。

### 5.2 组件映射解决了什么问题

通过组件映射，把 `<pre>` 替换成 `<CodeBlock>` 组件：

```vue
<CodeBlock>
  <BlockHeader label="JavaScript" copyable />
  <div class="code-body">
    <!-- Shiki 高亮后的 HTML -->
  </div>
</CodeBlock>
```

这样就能实现完整的交互能力（复制、折叠、行号），视觉风格也统一（Header + Body 结构），后续要加功能也方便。

### 5.3 其他组件的映射

**表格**：`<table>` → `<Table>`  
加了复制功能，响应式布局，样式统一。

**标题**：`<h1>~<h6>` → `<Heading>`  
支持折叠、锚点链接，TOC 也是从这里提取的。

**图片**：`<img>` → `<MdImage>`  
点击预览、懒加载、错误处理都在组件里做了。

**引用块**：`<blockquote>` → `<Blockquote>`  
可以根据类型（info/warning/error）显示不同的图标和样式。

## 六、性能优化

### 6.1 打包体积优化

**问题**：Shiki 默认打包所有语言，体积 10MB+

**方案**
1. 按需加载常用语言（15 种）
2. 使用 `createHighlighterCore` 替代 `getHighlighter`
3. 主题按需导入

**效果**：打包体积降至 ~800KB

### 6.2 运行时性能

**MDX 编译缓存**
```typescript
let cachedContent = ''
let cachedComponent: any = null

async function compileAndRender(raw: string) {
  if (raw === cachedContent && cachedComponent) {
    mdxComponent.value = cachedComponent
    return
  }
  
  const result = await evaluate(raw, options)
  cachedContent = raw
  cachedComponent = result.default
  mdxComponent.value = cachedComponent
}
```

**Shiki 单例模式**
```typescript
let highlighterInstance: HighlighterCore | null = null

export async function getHighlighter() {
  if (highlighterInstance) return highlighterInstance
  highlighterInstance = await createHighlighterCore(...)
  return highlighterInstance
}
```

**滚动监听优化**
```typescript
// 使用 passive 监听，提升滚动性能
window.addEventListener('scroll', handleScroll, { passive: true })

// 使用 IntersectionObserver 替代滚动计算
const observer = new IntersectionObserver(callback, options)
```

### 6.3 按需渲染

**骨架屏**：编译期间显示加载状态
```vue
<Skeleton v-if="isLoading" />
<component v-else :is="mdxComponent" />
```

**懒加载**：图片使用 `loading="lazy"`
```vue
<img :src="src" loading="lazy" />
```

## 七、API 设计

### 7.1 Props 设计原则

1. **合理的默认值**：开箱即用，无需配置
2. **渐进式增强**：基础功能默认开启，高级功能按需启用
3. **类型安全**：完整的 TypeScript 类型定义

### 7.2 核心 Props

```typescript
interface MarkdownRenderProps {
  // 内容
  raw: string                    // Markdown 原始文本
  format?: 'md' | 'mdx'          // 格式（默认 mdx）
  
  // 插件
  remarkGfm?: boolean            // GFM 扩展（默认 true）
  remarkPlugins?: PluggableList  // 自定义 remark 插件
  rehypePlugins?: PluggableList  // 自定义 rehype 插件
  
  // 组件
  components?: Record<string, any> // 自定义组件映射
  
  // 主题
  theme?: 'light' | 'dark'       // 主题（默认 light）
  style?: CSSProperties          // 自定义样式
  className?: string             // 自定义类名
  
  // 布局
  height?: string                // 固定高度（启用内部滚动）
  maxHeight?: string             // 最大高度
  
  // TOC
  showToc?: boolean              // 显示目录（默认 false）
  tocMinLevel?: number           // 最小层级（默认 2）
  tocMaxLevel?: number           // 最大层级（默认 4）
  tocMode?: 'sidebar' | 'embedded' // 布局模式
  
  // 其他
  showBackTop?: boolean          // 回到顶部按钮（默认 false）
  backTopThreshold?: number      // 显示阈值（默认 300px）
}
```

### 7.3 Events 设计

```typescript
interface Events {
  rendered: []                   // 渲染完成
  error: [error: Error]          // 渲染错误
  'toc-change': [toc: TocItem[]] // 目录变化
  'toc-click': [item: TocItem]   // 点击目录项
  'scroll-to-top': []            // 点击回到顶部
}
```

### 7.4 导出内容

```typescript
// 主组件
export { MarkdownRender }

// 子组件（可单独使用）
export { CodeBlock, Table, Blockquote, Heading, Toc }

// 基础组件
export { Icon, Tooltip, Toast, ImagePreview }

// 工具函数
export { toast, copyToClipboard, highlightCode }

// 类型定义
export type { MarkdownRenderProps, TocItem }
```

## 八、使用场景

### 8.1 文档站点

```vue
<template>
  <MarkdownRender 
    :raw="docContent"
    show-toc
    show-back-top
    :height="'calc(100vh - 60px)'"
  />
</template>
```

### 8.2 博客文章

```vue
<template>
  <MarkdownRender 
    :raw="article.content"
    :doc-title="article.title"
    show-toc
    toc-mode="embedded"
  />
</template>
```

### 8.3 Markdown 编辑器预览

```vue
<template>
  <div class="editor-layout">
    <textarea v-model="markdown" />
    <MarkdownRender :raw="markdown" theme="dark" />
  </div>
</template>
```

### 8.4 自定义组件嵌入

```vue
<template>
  <MarkdownRender 
    :raw="content"
    :components="{ Alert, Tabs, CodeSandbox }"
  />
</template>

<script setup>
// Markdown 中可以直接使用：
// <Alert type="warning">注意事项</Alert>
// <Tabs items={['Tab1', 'Tab2']} />
</script>
```

## 九、技术总结

### 9.1 架构层面

1. **MDX 编译**：支持组件嵌入，这是相比 marked/markdown-it 最大的优势
2. **组件映射**：把 HTML 标签映射成自定义组件，实现了代码复制、表格复制、标题折叠这些功能
3. **插件生态**：兼容 remark/rehype，社区插件可以直接用

### 9.2 功能层面

1. **渲染能力**：GFM、MDX、数学公式、代码高亮都支持
2. **交互体验**：复制、折叠、预览、导航这些基础能力都做了
3. **主题系统**：基于 CSS Variables，亮色/暗色主题切换方便，业务定制也简单

### 9.3 工程层面

1. **性能优化**：按需加载语言包，单例模式，滚动监听优化，打包体积控制在 1MB 以内
2. **类型支持**：TypeScript 类型定义完整
3. **开发体验**：默认值合理，API 简洁，开箱即用

### 9.4 维护性

1. **模块化**：组件、工具、样式分离，代码结构清晰
2. **可扩展**：支持自定义组件、插件、主题
3. **规范化**：遵循 Vue 3 Composition API 规范

## 十、后续规划

### 10.1 功能增强

- [ ] 支持更多 Shiki 主题（Nord、Dracula 等）
- [ ] 图片懒加载 + 预览功能
- [ ] 任务列表交互（点击切换状态）
- [ ] 代码块 diff 高亮
- [ ] Mermaid 图表支持

### 10.2 性能优化

- [ ] 虚拟滚动（长文档优化）
- [ ] Web Worker 编译（避免阻塞主线程）
- [ ] 增量渲染（只更新变化部分）

### 10.3 生态建设

- [ ] Nuxt 模块
- [ ] VitePress 插件
- [ ] CLI 工具（Markdown → HTML）
- [ ] 在线 Playground

---

**总结**：markview-vue 基于 MDX + 自定义组件的架构，解决了传统 Markdown 渲染库无法嵌入组件、交互能力弱、样式定制难的问题。目前已在 AI 对话和文档站点两个场景落地，渲染效果和交互体验都达到了预期。后续会继续优化性能，补充更多功能。
